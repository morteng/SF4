# Todo
1. Add comprehensive test coverage for all edge cases, especially date/time validation
2. Review all constants in `app/constants.py` to ensure consistency and completeness

### **Recent Changes**
1. **Fixed Missing Constants**:
   - Added `MISSING_FIELD_ERROR` and `INVALID_DATE_FORMAT` to `FlashMessages` class in `app/constants.py`.
   - Ensured all constants used in forms and tests are properly defined.

2. **Improved Form Validation**:
   - Updated form validation messages to use centralized constants from `app/constants.py`.
   - Added proper error handling for date/time validation in forms.

3. **Refactored Imports**:
   - Used lazy imports in `app/__init__.py` to avoid circular dependencies.
   - Moved shared utilities to `app/common/utils.py`.

4. **Fixed Test Failures**:
   - Resolved `ImportError` in `tests/test_forms.py` by adding missing constants.
   - Ensured all tests pass after adding required constants.

### **Things to Remember for Next Coding Session**
1. **Centralized Constants**:
   - Always define error messages and validation strings in `app/constants.py`.
   - Avoid hardcoding strings in forms, tests, or other modules.

2. **Property Implementation**:
   - Always define properties with `@property` before using `@<property>.setter`.
   - Validate property values in setters to maintain data integrity.

3. **Error Handling**:
   - Include proper error handling for `try` blocks.
   - Log errors with context to facilitate debugging.

4. **Testing**:
   - Add tests for edge cases, especially for date/time validation and rate limiting.
   - Use mocking tools like `freezegun` for deterministic time-based tests.

5. **Code Organization**:
   - Keep validation logic modular and reusable.
   - Avoid hardcoding strings; use constants instead.

6. **Rate Limiting**:
   - Ensure rate limiters are properly configured with valid string values (e.g., "10 per minute").
   - Validate rate limit values in setters to prevent invalid configurations.

7. **Circular Imports**:
   - Use lazy imports to avoid circular dependencies.
   - Refactor shared logic into utility modules to reduce import complexity.

### **Lessons Learned**
1. **Missing Constants**:
   - Missing constants can cause runtime errors, so add them as soon as they are identified.
   - Centralize all error messages and validation strings in `app/constants.py`.

2. **Testing**:
   - Comprehensive testing of date/time validation is essentialâ€”particularly with user-submitted data.
   - Use mocking tools like `freezegun` for predictable time-based tests.

3. **Code Organization**:
   - Modular and reusable validation logic improves maintainability.
   - Using constants instead of hardcoded strings reduces the chance of errors.

4. **Property Implementation**:
   - Always define properties with `@property` before using `@<property>.setter`.
   - Validate property values in setters to maintain data integrity.

5. **Error Handling**:
   - Proper error handling in property setters is crucial for maintaining data integrity.
   - Logging errors with context makes debugging easier.

6. **Rate Limiting**:
   - Proper configuration and validation of rate limiters prevent runtime errors.
   - Rate limit values should be validated in setters to ensure they are valid strings.

7. **Circular Imports**:
   - Circular imports can cause initialization errors and should be avoided.
   - Use lazy imports or refactor shared logic into utility modules to reduce import complexity.

### **Things to Remember for Next Coding Session**
1. **Property Implementation**:
   - Always define properties with `@property` before using `@<property>.setter`.
   - Validate property values in setters to maintain data integrity.

2. **Constants Management**:
   - Keep all error messages and validation strings in `app/constants.py`.
   - Verify that all required constants are defined and imported correctly.
   - Avoid duplicate definitions of constants to prevent `TypeError`.

3. **Error Handling**:
   - Include proper error handling for `try` blocks.
   - Log errors with context to facilitate debugging.

4. **Testing**:
   - Add tests for all properties and their validation logic.
   - Include edge cases for date/time validation and rate limiting.

5. **Code Organization**:
   - Keep validation logic modular and reusable.
   - Avoid hardcoding strings; use constants instead.

6. **Rate Limiting**:
   - Ensure rate limiters are properly configured with valid string values (e.g., "10 per minute").
   - Validate rate limit values in setters to prevent invalid configurations.

7. **Circular Imports**:
   - Use lazy imports to avoid circular dependencies.
   - Refactor shared logic into utility modules to reduce import complexity.

### **Lessons Learned**
1. **Property Implementation**:
   - Always define properties with `@property` before using `@<property>.setter`.
   - Validate property values in setters to maintain data integrity.

2. **Centralized Constants**:
   - Keeping all error messages and validation strings in `app/constants.py` ensures consistency and reduces the chance of typos.
   - Missing constants can cause runtime errors, so add them as soon as they are identified.
   - Duplicate definitions of constants can cause `TypeError`, so ensure each constant is defined only once.

3. **Error Handling**:
   - Proper error handling in property setters is crucial for maintaining data integrity.
   - Logging errors with context makes debugging easier.

4. **Testing**:
   - Comprehensive testing of properties and their validation logic is essential.
   - Edge cases for date/time validation and rate limiting should be thoroughly tested.

5. **Code Organization**:
   - Modular and reusable validation logic improves maintainability.
   - Using constants instead of hardcoded strings reduces the chance of errors.

6. **Rate Limiting**:
   - Proper configuration and validation of rate limiters prevent runtime errors.
   - Rate limit values should be validated in setters to ensure they are valid strings.

7. **Circular Imports**:
   - Circular imports can cause initialization errors and should be avoided.
   - Use lazy imports or refactor shared logic into utility modules to reduce import complexity.

### **Recent Changes**
1. **Fixed Duplicate Constants**:
   - Removed duplicate constants (`CREATE_SUCCESS`, `UPDATE_SUCCESS`, `DELETE_SUCCESS`, `MISSING_FIELD_ERROR`) from `FlashMessages` class in `app/constants.py`.

2. **Refactored Validation Logic**:
   - Moved reusable validation logic (e.g., `validate_application_deadline`) to `app/common/utils.py`.

3. **Improved Tests**:
   - Added edge case tests in `tests/test_base_crud_controller.py` for invalid form submissions and missing fields.

4. **Updated `requirements.txt`**:
   - Added `beautifulsoup4` for HTML parsing in tests.

5. **Fixed Property Implementation**:
   - Consolidated the `create_limit` property in `app/services/base_service.py` to avoid conflicts and ensure proper validation.

6. **Rate Limiter Configuration**:
   - Added validation for rate limit values in `app/services/base_service.py` to ensure they are valid strings.

### **Recent Changes**
1. **Added Missing Constants**:
   - Added `MISSING_FIELD_ERROR`, `USERNAME_REQUIRED`, `USERNAME_LENGTH`, `USERNAME_FORMAT`, and `EMAIL_REQUIRED` to `app/constants.py`.

2. **Refactored Validation Logic**:
   - Moved reusable validation logic (e.g., `validate_application_deadline`) to `app/common/utils.py`.

3. **Improved Tests**:
   - Added edge case tests in `tests/test_base_crud_controller.py` for invalid form submissions and missing fields.

4. **Updated `requirements.txt`**:
   - Added `beautifulsoup4` for HTML parsing in tests.

5. **Fixed Property Implementation**:
   - Consolidated the `create_limit` property in `app/services/base_service.py` to avoid conflicts and ensure proper validation.

6. **Rate Limiter Configuration**:
   - Added validation for rate limit values in `app/services/base_service.py` to ensure they are valid strings.


