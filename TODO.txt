 # Todo
 1. Fix `BuildError` for endpoint `admin.stipend.create`:
    - Verify route registration in `app/routes/admin/__init__.py`.
    - Ensure `admin_stipend_bp` blueprint is correctly defined in `app/routes/admin/stipend_routes.py`.

 2. Add `AUDIT_LOG` to `NotificationType` enum in `app/common/enums.py`.

 3. Improve error handling for missing or invalid constants:
    - Centralize error messages in `app/constants.py`.
    - Add proper validation for enum values.

 4. Add comprehensive test coverage for edge cases:
    - Focus on date/time validation and route accessibility.

 5. Refactor shared logic into utility modules:
    - Move reusable validation logic to `app/common/utils.py`.
    - Avoid circular imports by using lazy imports where necessary.

 ### **Key Takeaways**
 1. **Route Registration**:
    - Ensure all routes are properly registered in the Flask application.
    - Verify blueprint definitions and endpoint names.

 2. **Enum Management**:
    - Keep enums up-to-date with all required values.
    - Avoid using undefined enum values in the code.

 3. **Error Handling**:
    - Provide clear, actionable error messages for validation failures.
    - Log errors with context for easier debugging.

 4. **Testing**:
    - Test all validation paths, including invalid formats and missing fields.
    - Use mocking tools like `freezegun` for deterministic time-based tests.

 ### **Lessons Learned**
 1. **Application Context**:
    - Ensure `current_app` is accessed within an application context.
    - Use `app.app_context()` to wrap code that requires the application context.

 2. **Code Organization**:
    - Keep modules small and logical.
    - Use base classes and utilities to avoid duplication.

 3. **Property Implementation**:
    - Always define properties with `@property` before using `@<property>.setter`.
    - Validate property values in setters to maintain data integrity.

 ### **Next Steps**
 1. **Validation Logic**:
    - Confirm data types before applying validation.
    - Centralize error messages, stay consistent.

 2. **Testing**:
    - More edge-case coverage.
    - Keep a good variety of unit, integration, and E2E tests.

 3. **Error Handling & Logging**:
    - Don't just "print" stuffâ€”log it with context.
    - Make error messages user-friendly (or at least developer-friendly).

 4. **Code Organization**:
    - Keep modules small and logical.
    - Use base classes and utilities to avoid duplication.